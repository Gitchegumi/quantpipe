"""{{ strategy_class_name }} strategy implementation.

This module provides a trading strategy implementation conforming to
the Strategy Protocol. Generated by scaffold command.

Example:
    from src.strategy.{{ strategy_name }} import {{ strategy_class_name }}

    strategy = {{ strategy_class_name }}()
    signals = strategy.generate_signals(candles, parameters)
"""

from typing import Optional

import numpy as np

from src.models.visualization_config import (
    IndicatorDisplayConfig,
    VisualizationConfig,
)
from src.strategy.base import Strategy, StrategyMetadata


class {{ strategy_class_name }}:
    """{{ description }}

    This strategy implements the Strategy Protocol, providing:
    - metadata: Strategy configuration and required indicators
    - generate_signals: Signal generation from candle data
    - scan_vectorized: (Optional) High-performance batch scanning

    TODO: Customize this strategy by:
    1. Update required_indicators in metadata
    2. Implement your signal logic in generate_signals
    3. (Optional) Implement scan_vectorized for better performance
    """

    @property
    def metadata(self) -> StrategyMetadata:
        """Return strategy metadata including required indicators.

        Returns:
            StrategyMetadata with strategy configuration.

        TODO: Update the following:
        - name: Your unique strategy identifier
        - version: Semantic version (e.g., "1.0.0")
        - required_indicators: List of indicators your strategy needs
        - tags: Classification tags for filtering
        """
        return StrategyMetadata(
            name="{{ strategy_name }}",
            version="1.0.0",
            required_indicators=[
                # TODO: Add your required indicators here
                # Examples: "ema20", "ema50", "rsi14", "atr14", "stoch_rsi"
                "ema20",
            ],
            tags=[{{ tags_list }}],
            max_concurrent_positions=1,
        )

    def get_visualization_config(self) -> Optional[VisualizationConfig]:
        """Return visualization configuration for strategy indicators.

        Returns:
            VisualizationConfig for chart display, or None for auto-detection.

        TODO: Configure how your indicators appear in backtest charts.
        """
        return VisualizationConfig(
            price_overlays=[
                # TODO: Add price overlay indicators (e.g., EMAs)
                IndicatorDisplayConfig(name="ema20", color="#FFD700"),
            ],
            oscillators=[
                # TODO: Add oscillator indicators (e.g., RSI, StochRSI)
            ],
        )

    def generate_signals(
        self, candles: list, parameters: dict, direction: str = "BOTH"
    ) -> list:
        """Generate trade signals from candle data.

        Args:
            candles: List of Candle objects with indicators populated.
            parameters: Strategy parameters dict with keys like:
                - stop_atr_multiplier: ATR multiplier for stop loss
                - take_profit_r: R-multiple for take profit target
            direction: Trade direction - "LONG", "SHORT", or "BOTH".

        Returns:
            List of TradeSignal objects.

        TODO: Implement your signal generation logic here.
        Access indicator values via candle attributes (e.g., candle.ema20).
        """
        # TODO: Implement your signal generation logic
        # Example structure:
        #
        # from src.strategy.{{ strategy_name }}.signal_generator import (
        #     generate_long_signals,
        #     generate_short_signals,
        # )
        #
        # signals = []
        # if direction in ("LONG", "BOTH"):
        #     signals.extend(generate_long_signals(candles, parameters))
        # if direction in ("SHORT", "BOTH"):
        #     signals.extend(generate_short_signals(candles, parameters))
        # return signals

        return []

    def scan_vectorized(
        self,
        close: np.ndarray,
        indicator_arrays: dict[str, np.ndarray],
        parameters: dict,
        direction: str,
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """Scan for signals using vectorized operations.

        This optional method provides high-performance batch scanning
        using NumPy array operations instead of iterating over candles.

        Args:
            close: Close price array.
            indicator_arrays: Dictionary of indicator name -> NumPy array.
            parameters: Strategy-specific parameters.
            direction: Trading direction ("LONG", "SHORT", or "BOTH").

        Returns:
            Tuple of (signal_indices, stop_prices, target_prices, position_sizes).

        Raises:
            NotImplementedError: Remove this when you implement the method.

        TODO: Implement vectorized signal scanning for better performance.
        """
        raise NotImplementedError(
            "scan_vectorized not implemented. "
            "Remove this method to use generate_signals instead."
        )


# Global instance for easy access
{{ strategy_constant }} = {{ strategy_class_name }}()
