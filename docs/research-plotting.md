# Visualizing a Large Trading Simulation with Polars and Interactive Charts

## Using Polars Without Pandas Overhead

Polars is a great choice for high-performance backtesting - it's _much_ faster and more memory-efficient than Pandas for large datasets[\[1\]](https://medium.databento.com/how-to-use-polars-with-market-data-from-databento-bc8624c72796?gi=4aee23033f0d#:~:text=One%20of%20my%20favorite%20parts,due%20to%20a%20few%20reasons). However, many Python plotting libraries (including lightweight-charts-python) traditionally expect Pandas DataFrames. Converting a ~6.8 million row Polars DataFrame to Pandas can indeed be slow and memory-heavy.

**Solution:** Leverage new interfaces that accept Polars directly, or minimize conversion. The data science ecosystem is evolving to support Polars natively. For example, Plotly 6+ and Altair now use the DataFrame interchange protocol (via **Narwhals**) to accept Polars objects without full conversion[\[2\]](https://docs.pola.rs/user-guide/misc/visualization/#:~:text=Plotly). Similarly, Polars 1.6 introduced an Altair backend so you can call df.plot(...) and it will handle Polars internally[\[3\]](https://pola.rs/posts/lightweight_plotting/#:~:text=Altair%20devs%20were%20keen%20to,a%20new%20library%20called%20Narwhals)[\[4\]](https://pola.rs/posts/lightweight_plotting/#:~:text=The%20idea%20is%3A). In practice, this means you could use libraries like **Altair**, **hvPlot/HoloViews**, or **Plotly** to create charts directly from Polars DataFrames with minimal overhead. These libraries will either convert Polars via zero-copy Arrow buffers or use Polars under the hood, avoiding the slow path of materializing a giant Pandas DataFrame.

If you must use lightweight-charts-python specifically (for its TradingView-style features), consider **only converting the data you need for the chart**. For example, instead of converting the entire 6.8M rows to Pandas at once, use Polars to filter or slice the dataset first. You might generate a subset DataFrame (e.g. one symbol or a specific date range) and then call Chart.set() on that smaller Pandas DataFrame. Polars can efficiently slice data, and you'll avoid the brunt of converting the full dataset. In summary, continue using Polars for all heavy data prep (indicators, trade signals, P&L calculations) - it excels at that - and then hand off a trimmed result to the charting library.

## Handling 6.8 Million Points in Interactive Charts

Trying to plot millions of points interactively is challenging for any library. Even though TradingView's **Lightweight Charts** (the JS library) can _accept_ very large datasets, there's a practical limit to what can be drawn at once. In fact, each data point (e.g. each 1-minute candle) needs at least one pixel on the screen to be visible[\[5\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=4). So if your chart is, say, 1200 pixels wide, it can meaningfully display on the order of 1200 bars at a time - not 6.8 million simultaneously. The official guidance notes there's no hardcoded data size limit, but you simply **can't visualize millions of points at once** on a fixed-width chart[\[5\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=4). The library will either over-compress them or you'll have to scroll/zoom to see different portions. (In fact, the Lightweight Charts team demonstrated a 1.2 million candlestick example to prove it _can_ load that many points[\[6\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=Here%20is%20an%20example%20of,net%2FTradingView%2Ffg7yez2s), but obviously not all are on screen concurrently.)

**Solution:** Use an approach that either dynamically loads or aggregates data, while preserving the 1-minute fidelity when needed. Since downsampling (dropping data points) isn't acceptable for your use case, consider these strategies:

- **Multi-Resolution Data (Timeframe Aggregation):** Pre-compute higher timeframe bars (e.g. 5-minute, 1-hour) in Polars. You can then utilize the chart's controls to switch resolutions. For example, when zoomed out or viewing the full range, display 30-minute or 1-hour bars; when zoomed in or for detailed trade analysis, switch to 1-minute bars. The lightweight-charts-python library supports timeframe selectors and can load a new dataset on demand when the user changes interval[\[7\]](https://pypi.org/project/lightweight-charts-esistjosh/#:~:text=def%20on_timeframe_selection%28chart%29%3A%20%20,timeframe%27%5D.value). In the provided examples, the UI's timeframe dropdown triggers an on_timeframe_selection callback, which loads a different CSV (dataset) for that timeframe[\[8\]](https://pypi.org/project/lightweight-charts-esistjosh/#:~:text=chart.topbar)[\[9\]](https://pypi.org/project/lightweight-charts-esistjosh/#:~:text=chart,func%3Don_timeframe_selection). You could adopt a similar pattern: use Polars to generate CSVs or DataFrames for each timeframe (or a daily vs intraday split), and have the chart swap to the appropriate one. This way, you're **not downsampling in a lossy way**; you're simply choosing the proper granularity for the view. All trade entries/exits will still align correctly when you switch back to 1-minute mode for the detailed view.
- **Dynamic Loading / Windowing:** Instead of loading the entire history into the chart at once, load only a window of data and update it as needed. For instance, you might initially plot the last N days of data (where N is small enough to handle interactively), and then implement navigation to move the window. Many interactive charting solutions use this pattern (e.g. a scrollbar or "load more" as you pan). While the current lightweight-charts-python API doesn't automatically page data, you can achieve it manually. The JS library does allow you to set or add data points dynamically, so in Python you could catch events like panning or a custom slider and then call Chart.set() or Chart.update() with a new chunk of data. In practice, you might handle this by listening for the chart's visible range change (if exposed) or by providing UI controls for the user to jump to a certain date range, then using Polars to fetch that range and update the chart. This ensures the chart only holds perhaps a few thousand points at any given time, keeping it responsive.
- **Datashader (Visualization Rasterization):** If you're open to other libraries for a static analysis view, consider using **HoloViews + Datashader** (via hvPlot or Panel) for the truly large dataset. Datashader is a rendering pipeline that **aggregates millions of points into an image on the fly**, based on the current view. Unlike standard interactive charts that send every point to the browser, Datashader computes what you see (e.g. density of points, min/max in a pixel) server-side, so it can handle billions of points[\[10\]](https://discourse.bokeh.org/t/very-big-data-plotting/7491#:~:text=For%20large%20data%20sets%20another,can%20handle%20billions%20of%20points)[\[11\]](https://data-dive.com/interactive-large-data-plots-datashader/#:~:text=HoloViz%20initiative,data%20here%20and%20follow%20along). HoloViews has built-in integration to use Datashader for large time series, maintaining interactivity for zooming/panning[\[11\]](https://data-dive.com/interactive-large-data-plots-datashader/#:~:text=HoloViz%20initiative,data%20here%20and%20follow%20along). The result is that you can pan/zoom smoothly through your 6.8M points and see all the data as a continuous image (with indicators like min/max spikes retained visually), without dropping data - it's just rendered as pixels. This is great for identifying patterns or outliers in the full backtest history. However, the trade-off is you lose the ability to hover each individual point or click on a specific trade, since the data is now an image representation. Still, you could overlay markers for trade entries/exits on top of a datashader-generated price chart for a hybrid approach (e.g. plot trade markers for those specific timestamps, which are far fewer than 6.8M, on the datashaded price plot).

Given that _downsampling is not an option_ (you need the exact 1-minute timing for trades), the **multi-resolution** or **datashader** approaches are most appropriate. Multi-resolution preserves exact data by switching context (you never actually mix 1-min and 5-min data; you just choose one at a time for viewing). Datashader preserves the _information_ in the full data but merges it visually. Both approaches ensure that when you zoom or focus in, you're seeing the true 1-minute data at that point in time.

## Static vs Interactive Charts (Building the Backtester vs Forward Testing)

For your immediate needs while building the backtester, static charts might suffice. You could generate a static line chart of the profit/equity curve and a few static snapshots of price with trades marked, just to validate your strategy logic. Libraries like Matplotlib or Altair can plot Polars data (via internal conversion) relatively easily. For example, Polars integrates with Altair so you can do df.plot.line(x=..., y=...) directly[\[12\]](https://pola.rs/posts/lightweight_plotting/#:~:text=%28%20pl.scan_csv%28,)[\[13\]](https://pola.rs/posts/lightweight_plotting/#:~:text=.filter%28pl.col%28,). If the profit curve is over 6.8M points (e.g. equity updated every minute), consider plotting a smoother version for visual clarity - for instance, equity by day or equity at each trade event. This doesn't change the simulation, it just makes the chart less noisy to look at. Since you _don't_ want to lose detail in the trade visualization, keep the detailed price & trades chart at 1-minute granularity, but you might not need to draw all 6.8M bars for a quick overview of the equity trajectory.

When you move to **forward testing (live or paper trading)**, you'll want interactive, updating charts - and here lightweight-charts-python can shine. The library was designed with live data in mind, providing methods to stream updates efficiently[\[14\]](https://github.com/louisnw01/lightweight-charts-python#:~:text=Features). In a forward-test scenario, you won't be pumping millions of points in at once; instead you'll be appending new data as it comes in. You can initialize the chart with the most recent history (or even start empty), then on each new minute/tick: use chart.update(new_bar) to add the latest data point. The library will only send that incremental update to the browser, rather than reloading everything. This is very efficient[\[15\]](https://discourse.bokeh.org/t/very-big-data-plotting/7491#:~:text=Appending%20data%20to%20a%20ColumnDataSource). You can also add markers or annotations for trade entries/exits in real-time. For example, if your strategy opens a trade, you could call something like chart.marker(position='aboveBar', color='green', text='Buy') at that timestamp. The lightweight-charts README shows how you can add a marker dynamically when a condition is met (in their case, a price crossing a threshold)[\[16\]](https://github.com/louisnw01/lightweight-charts-python#:~:text=for%20i%2C%20series%20in%20df2,update%28series) - you can do the same for your trade signals.

**Bottom line:** Use Polars to handle your heavy data processing and slicing, and use an interactive chart library in a smart way - either by leveraging multi-scale data or a rendering tool like Datashader - to cope with the visualization of millions of points. This hybrid approach will let you inspect the full backtest (indicators and trades on the price chart, plus the profit curve) without freezing your tools. As you iterate, you can start static for simplicity, then gradually add interactivity. Many users find that for exploring large backtests, a combination of static summary charts and an interactive drill-down (on smaller chunks or using datashader) works best. And when you're ready to go live, lightweight-charts-python is capable of maintaining an updating chart of your strategy's performance and signals - just feed it incrementally. In fact, the TradingView Lightweight Charts can handle _"infinite"_ historical data in theory by scrolling, as long as you respect the practical pixel limit and load data as needed[\[5\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=4)[\[6\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=Here%20is%20an%20example%20of,net%2FTradingView%2Ffg7yez2s). With careful design (pre-aggregating or lazy-loading data and using Polars to optimize every step), you'll have interactive charts that meet your needs without relying on MT5 or other platforms.

**Sources:** Polars vs Pandas performance[\[1\]](https://medium.databento.com/how-to-use-polars-with-market-data-from-databento-bc8624c72796?gi=4aee23033f0d#:~:text=One%20of%20my%20favorite%20parts,due%20to%20a%20few%20reasons)[\[17\]](https://medium.databento.com/how-to-use-polars-with-market-data-from-databento-bc8624c72796?gi=4aee23033f0d#:~:text=,minimizing%20the%20potential%20for%20errors); Plotly/Altair support for Polars[\[2\]](https://docs.pola.rs/user-guide/misc/visualization/#:~:text=Plotly); Lightweight Charts large-data capability[\[5\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=4)[\[6\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=Here%20is%20an%20example%20of,net%2FTradingView%2Ffg7yez2s); HoloViews+Datashader for big data[\[11\]](https://data-dive.com/interactive-large-data-plots-datashader/#:~:text=HoloViz%20initiative,data%20here%20and%20follow%20along); Bokeh/holoviews guidance on billion-point visualization[\[10\]](https://discourse.bokeh.org/t/very-big-data-plotting/7491#:~:text=For%20large%20data%20sets%20another,can%20handle%20billions%20of%20points); and lightweight-charts-python documentation for streaming updates and events[\[14\]](https://github.com/louisnw01/lightweight-charts-python#:~:text=Features)[\[16\]](https://github.com/louisnw01/lightweight-charts-python#:~:text=for%20i%2C%20series%20in%20df2,update%28series).

[\[1\]](https://medium.databento.com/how-to-use-polars-with-market-data-from-databento-bc8624c72796?gi=4aee23033f0d#:~:text=One%20of%20my%20favorite%20parts,due%20to%20a%20few%20reasons) [\[17\]](https://medium.databento.com/how-to-use-polars-with-market-data-from-databento-bc8624c72796?gi=4aee23033f0d#:~:text=,minimizing%20the%20potential%20for%20errors) How to use Polars with market data from Databento | by Databento | Medium

<https://medium.databento.com/how-to-use-polars-with-market-data-from-databento-bc8624c72796?gi=4aee23033f0d>

[\[2\]](https://docs.pola.rs/user-guide/misc/visualization/#:~:text=Plotly) Visualization - Polars user guide

<https://docs.pola.rs/user-guide/misc/visualization/>

[\[3\]](https://pola.rs/posts/lightweight_plotting/#:~:text=Altair%20devs%20were%20keen%20to,a%20new%20library%20called%20Narwhals) [\[4\]](https://pola.rs/posts/lightweight_plotting/#:~:text=The%20idea%20is%3A) [\[12\]](https://pola.rs/posts/lightweight_plotting/#:~:text=%28%20pl.scan_csv%28,) [\[13\]](https://pola.rs/posts/lightweight_plotting/#:~:text=.filter%28pl.col%28,) Polars - Polars has a new lightweight plotting backend

<https://pola.rs/posts/lightweight_plotting/>

[\[5\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=4) [\[6\]](https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time#:~:text=Here%20is%20an%20example%20of,net%2FTradingView%2Ffg7yez2s) timestamp with timezone - Can Lightweight Charts handle large datasets - like 1.2 millions bar candle timeseries? - Stack Overflow

<https://stackoverflow.com/questions/71746193/can-lightweight-charts-handle-large-datasets-like-1-2-millions-bar-candle-time>

[\[7\]](https://pypi.org/project/lightweight-charts-esistjosh/#:~:text=def%20on_timeframe_selection%28chart%29%3A%20%20,timeframe%27%5D.value) [\[8\]](https://pypi.org/project/lightweight-charts-esistjosh/#:~:text=chart.topbar) [\[9\]](https://pypi.org/project/lightweight-charts-esistjosh/#:~:text=chart,func%3Don_timeframe_selection) lightweight-charts-esistjosh Â· PyPI

<https://pypi.org/project/lightweight-charts-esistjosh/>

[\[10\]](https://discourse.bokeh.org/t/very-big-data-plotting/7491#:~:text=For%20large%20data%20sets%20another,can%20handle%20billions%20of%20points) [\[15\]](https://discourse.bokeh.org/t/very-big-data-plotting/7491#:~:text=Appending%20data%20to%20a%20ColumnDataSource) VERY big data plotting - Community Support - Bokeh Discourse

<https://discourse.bokeh.org/t/very-big-data-plotting/7491>

[\[11\]](https://data-dive.com/interactive-large-data-plots-datashader/#:~:text=HoloViz%20initiative,data%20here%20and%20follow%20along) Interactive plots of large data sets made easy: Datashader - Data-Dive

<https://data-dive.com/interactive-large-data-plots-datashader/>

[\[14\]](https://github.com/louisnw01/lightweight-charts-python#:~:text=Features) [\[16\]](https://github.com/louisnw01/lightweight-charts-python#:~:text=for%20i%2C%20series%20in%20df2,update%28series) GitHub - louisnw01/lightweight-charts-python: Python framework for TradingView's Lightweight Charts JavaScript library.

<https://github.com/louisnw01/lightweight-charts-python>
